const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const ScheduledPost = require('../models/scheduledPost');
const RecurringSchedule = require('../models/recurringSchedule');
const ContentDraft = require('../models/contentDraft');
const AIML = require('../../AIML');

// Get all scheduled posts for user
router.get('/posts', auth, async (req, res) => {
    try {
        const posts = await ScheduledPost.find({ userId: req.user.userId })
            .sort({ scheduledFor: 1 })
            .populate('recurringScheduleId', 'name');

        res.json({
            success: true,
            posts
        });
    } catch (error) {
        console.error('Error fetching scheduled posts:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch scheduled posts'
        });
    }
});

// Create new scheduled post
router.post('/posts', auth, async (req, res) => {
    try {
        const { platform, content, scheduledFor, contentType, metadata } = req.body;

        if (!platform || !content || !scheduledFor) {
            return res.status(400).json({
                success: false,
                error: 'Platform, content, and scheduled time are required'
            });
        }

        const scheduledPost = new ScheduledPost({
            userId: req.user.userId,
            platform,
            content,
            scheduledFor: new Date(scheduledFor),
            contentType: contentType || 'Personal',
            metadata: metadata || {},
            autoGenerated: false
        });

        await scheduledPost.save();

        res.status(201).json({
            success: true,
            post: scheduledPost
        });
    } catch (error) {
        console.error('Error creating scheduled post:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create scheduled post'
        });
    }
});

// Get all recurring schedules for user
router.get('/recurring', auth, async (req, res) => {
    try {
        const schedules = await RecurringSchedule.find({ userId: req.user.userId })
            .sort({ createdAt: -1 });

        res.json({
            success: true,
            schedules
        });
    } catch (error) {
        console.error('Error fetching recurring schedules:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch recurring schedules'
        });
    }
});

// Create new recurring schedule
router.post('/recurring', auth, async (req, res) => {
    try {
        const { name, platform, contentType, frequency, timeOfDay, dayOfWeek, dayOfMonth, contentPrompts, settings } = req.body;

        if (!name || !platform || !contentType || !frequency || !timeOfDay) {
            return res.status(400).json({
                success: false,
                error: 'Name, platform, content type, frequency, and time are required'
            });
        }

        // Calculate next generation time
        const nextGeneration = calculateNextGeneration(frequency, timeOfDay, dayOfWeek, dayOfMonth);

        const recurringSchedule = new RecurringSchedule({
            userId: req.user.userId,
            name,
            platform,
            contentType,
            frequency,
            timeOfDay,
            dayOfWeek,
            dayOfMonth,
            nextGeneration,
            contentPrompts: contentPrompts || [],
            settings: settings || {}
        });

        await recurringSchedule.save();

        res.status(201).json({
            success: true,
            schedule: recurringSchedule
        });
    } catch (error) {
        console.error('Error creating recurring schedule:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create recurring schedule'
        });
    }
});

// Generate content for recurring schedule
router.post('/recurring/:id/generate', auth, async (req, res) => {
    try {
        const schedule = await RecurringSchedule.findOne({
            _id: req.params.id,
            userId: req.user.userId,
            active: true
        });

        if (!schedule) {
            return res.status(404).json({
                success: false,
                error: 'Recurring schedule not found or inactive'
            });
        }

        // Get user profile for AI generation
        const User = require('../models/user');
        const user = await User.findById(req.user.userId);

        // Generate content using AI
        const contentPrompt = schedule.contentPrompts.length > 0
            ? schedule.contentPrompts[Math.floor(Math.random() * schedule.contentPrompts.length)]
            : `Create a ${schedule.contentType.toLowerCase()} post for ${schedule.platform}`;

        const aiResult = await AIML.generateContent(contentPrompt, {
            platform: schedule.platform.toLowerCase(),
            tone: schedule.settings.tone || user.tone || 'professional',
            userProfile: {
                niche: user.niche,
                goals: user.goals,
                voiceDescription: user.toneProfile?.voiceDescription
            },
            contentGoals: user.goals || []
        });

        if (aiResult.success) {
            // Create scheduled post
            const scheduledPost = new ScheduledPost({
                userId: req.user.userId,
                platform: schedule.platform,
                content: aiResult.content,
                scheduledFor: schedule.nextGeneration,
                contentType: schedule.contentType,
                metadata: aiResult.metadata || {},
                autoGenerated: true,
                recurringScheduleId: schedule._id
            });

            await scheduledPost.save();

            // Update recurring schedule
            schedule.lastGenerated = new Date();
            schedule.nextGeneration = calculateNextGeneration(
                schedule.frequency,
                schedule.timeOfDay,
                schedule.dayOfWeek,
                schedule.dayOfMonth
            );
            await schedule.save();

            res.json({
                success: true,
                post: scheduledPost,
                nextGeneration: schedule.nextGeneration
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Failed to generate content'
            });
        }
    } catch (error) {
        console.error('Error generating scheduled content:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to generate scheduled content'
        });
    }
});

// Helper function to calculate next generation time
function calculateNextGeneration(frequency, timeOfDay, dayOfWeek, dayOfMonth) {
    const now = new Date();
    const [hours, minutes] = timeOfDay.split(':').map(Number);

    let nextDate = new Date();
    nextDate.setHours(hours, minutes, 0, 0);

    switch (frequency) {
        case 'daily':
            if (nextDate <= now) {
                nextDate.setDate(nextDate.getDate() + 1);
            }
            break;
        case 'weekly':
            nextDate.setDate(nextDate.getDate() + (7 - nextDate.getDay() + dayOfWeek) % 7);
            if (nextDate <= now) {
                nextDate.setDate(nextDate.getDate() + 7);
            }
            break;
        case 'biweekly':
            nextDate.setDate(nextDate.getDate() + (7 - nextDate.getDay() + dayOfWeek) % 7);
            if (nextDate <= now) {
                nextDate.setDate(nextDate.getDate() + 14);
            }
            break;
        case 'monthly':
            nextDate.setDate(dayOfMonth);
            if (nextDate <= now) {
                nextDate.setMonth(nextDate.getMonth() + 1);
            }
            break;
    }

    return nextDate;
}

module.exports = router;